#!/usr/bin/env python3
"""
Script de tests autonome pour les composants critiques d'AgoraFlux
Tests de s√©curit√©, authentification et permissions
"""

import sys
import os
import traceback
from datetime import datetime, timedelta

# Ajouter le r√©pertoire parent au PYTHONPATH
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Imports du syst√®me
from app.core.security import SecurityUtils, PermissionChecker
from app.models.user import UserRole
from app.core.database import SessionLocal, engine, Base
from app.models.user import User
from app.models.project import Project, ProjectStatus, ProjectVisibility
from app.models.permissions import ProjectPermission, ProjectRole
from app.services.permission_service import PermissionService
from app.core.security_logging import SecurityLogger, SecurityEventType, SecurityLog


class SecurityTestSuite:
    """Suite de tests pour la s√©curit√©"""
    
    def __init__(self):
        self.tests_passed = 0
        self.tests_failed = 0
        self.db = SessionLocal()
    
    def run_test(self, test_name, test_func):
        """Ex√©cute un test et affiche le r√©sultat"""
        try:
            print(f"   üß™ {test_name}...", end=" ")
            test_func()
            print("‚úÖ")
            self.tests_passed += 1
        except Exception as e:
            print(f"‚ùå {str(e)}")
            self.tests_failed += 1
            if "--verbose" in sys.argv:
                traceback.print_exc()
    
    def test_password_security(self):
        """Tests de s√©curit√© des mots de passe"""
        print("üìã Tests de s√©curit√© des mots de passe")
        
        def test_password_hashing():
            password = "testpassword123"
            hash1 = SecurityUtils.get_password_hash(password)
            hash2 = SecurityUtils.get_password_hash(password)
            
            assert SecurityUtils.verify_password(password, hash1)
            assert SecurityUtils.verify_password(password, hash2)
            assert hash1 != hash2, "Les hashes doivent √™tre diff√©rents (salt)"
            assert not SecurityUtils.verify_password("wrongpassword", hash1)
        
        def test_password_strength():
            # Mots de passe valides
            assert SecurityUtils.validate_password_strength("Password123")
            assert SecurityUtils.validate_password_strength("MyStr0ngP@ss")
            
            # Mots de passe invalides
            assert not SecurityUtils.validate_password_strength("123")  # Trop court
            assert not SecurityUtils.validate_password_strength("password")  # Pas de majuscule/chiffre
            assert not SecurityUtils.validate_password_strength("PASSWORD123")  # Pas de minuscule
            assert not SecurityUtils.validate_password_strength("Password")  # Pas de chiffre
        
        self.run_test("Hachage et v√©rification des mots de passe", test_password_hashing)
        self.run_test("Validation de la force des mots de passe", test_password_strength)
    
    def test_jwt_security(self):
        """Tests de s√©curit√© JWT"""
        print("üìã Tests de s√©curit√© JWT")
        
        def test_token_creation_verification():
            data = {"sub": "123", "email": "test@example.com", "role": "user"}
            
            # Token d'acc√®s
            access_token = SecurityUtils.create_access_token(data)
            assert access_token is not None
            assert isinstance(access_token, str)
            
            payload = SecurityUtils.verify_token(access_token, "access")
            assert payload is not None
            assert payload["sub"] == "123"
            assert payload["email"] == "test@example.com"
            assert payload["type"] == "access"
            
            # Token de refresh
            refresh_token = SecurityUtils.create_refresh_token(data)
            assert refresh_token is not None
            
            refresh_payload = SecurityUtils.verify_token(refresh_token, "refresh")
            assert refresh_payload is not None
            assert refresh_payload["type"] == "refresh"
        
        def test_invalid_tokens():
            # Token invalide
            payload = SecurityUtils.verify_token("invalid.jwt.token", "access")
            assert payload is None
            
            # Mauvais type de token
            data = {"sub": "123", "type": "access"}
            access_token = SecurityUtils.create_access_token(data)
            payload = SecurityUtils.verify_token(access_token, "refresh")  # Cherche refresh mais c'est access
            assert payload is None
        
        self.run_test("Cr√©ation et v√©rification des tokens", test_token_creation_verification)
        self.run_test("Gestion des tokens invalides", test_invalid_tokens)
    
    def test_role_permissions(self):
        """Tests des permissions par r√¥le"""
        print("üìã Tests des permissions par r√¥le")
        
        def test_admin_permissions():
            assert PermissionChecker.can_admin(UserRole.ADMIN)
            assert not PermissionChecker.can_admin(UserRole.MODERATOR)
            assert not PermissionChecker.can_admin(UserRole.USER)
        
        def test_moderation_permissions():
            assert PermissionChecker.can_moderate(UserRole.ADMIN)
            assert PermissionChecker.can_moderate(UserRole.MODERATOR)
            assert not PermissionChecker.can_moderate(UserRole.USER)
        
        def test_project_access_permissions():
            # Projets publics - tout le monde peut acc√©der
            assert PermissionChecker.can_access_project(UserRole.USER, "public", False)
            assert PermissionChecker.can_access_project(UserRole.MODERATOR, "public", False)
            assert PermissionChecker.can_access_project(UserRole.ADMIN, "public", False)
            
            # Projets priv√©s - propri√©taire et admin seulement
            assert not PermissionChecker.can_access_project(UserRole.USER, "private", False)
            assert PermissionChecker.can_access_project(UserRole.USER, "private", True)  # Propri√©taire
            assert PermissionChecker.can_access_project(UserRole.ADMIN, "private", False)
            
            # Projets restreints - propri√©taire, mod√©rateurs et admins
            assert not PermissionChecker.can_access_project(UserRole.USER, "restricted", False)
            assert PermissionChecker.can_access_project(UserRole.USER, "restricted", True)  # Propri√©taire
            assert PermissionChecker.can_access_project(UserRole.MODERATOR, "restricted", False)
            assert PermissionChecker.can_access_project(UserRole.ADMIN, "restricted", False)
        
        def test_edit_delete_permissions():
            # √âdition - propri√©taire et admin
            assert not PermissionChecker.can_edit_project(UserRole.USER, False)
            assert PermissionChecker.can_edit_project(UserRole.USER, True)  # Propri√©taire
            assert not PermissionChecker.can_edit_project(UserRole.MODERATOR, False)
            assert PermissionChecker.can_edit_project(UserRole.ADMIN, False)
            
            # Suppression - m√™me logique
            assert not PermissionChecker.can_delete_project(UserRole.USER, False)
            assert PermissionChecker.can_delete_project(UserRole.USER, True)  # Propri√©taire
            assert not PermissionChecker.can_delete_project(UserRole.MODERATOR, False)
            assert PermissionChecker.can_delete_project(UserRole.ADMIN, False)
        
        def test_comment_moderation():
            # Mod√©ration des commentaires
            assert PermissionChecker.can_moderate_comment(UserRole.USER, True)  # Son propre commentaire
            assert not PermissionChecker.can_moderate_comment(UserRole.USER, False)  # Commentaire d'autrui
            assert PermissionChecker.can_moderate_comment(UserRole.MODERATOR, False)  # Tous les commentaires
            assert PermissionChecker.can_moderate_comment(UserRole.ADMIN, False)  # Tous les commentaires
        
        self.run_test("Permissions d'administration", test_admin_permissions)
        self.run_test("Permissions de mod√©ration", test_moderation_permissions)
        self.run_test("Permissions d'acc√®s aux projets", test_project_access_permissions)
        self.run_test("Permissions d'√©dition/suppression", test_edit_delete_permissions)
        self.run_test("Permissions de mod√©ration des commentaires", test_comment_moderation)
    
    def test_project_permissions(self):
        """Tests des permissions par projet"""
        print("üìã Tests des permissions par projet")
        
        def test_permission_defaults():
            # Permissions par d√©faut pour chaque r√¥le
            admin_perms = ProjectPermission.get_default_permissions_for_role(ProjectRole.ADMIN)
            assert admin_perms["can_view_project"] is True
            assert admin_perms["can_edit_project"] is True
            assert admin_perms["can_delete_project"] is True
            assert admin_perms["can_manage_users"] is True
            assert admin_perms["can_moderate_comments"] is True
            assert admin_perms["can_export_data"] is True
            
            moderator_perms = ProjectPermission.get_default_permissions_for_role(ProjectRole.MODERATOR)
            assert moderator_perms["can_view_project"] is True
            assert moderator_perms["can_upload_datasets"] is True
            assert moderator_perms["can_moderate_comments"] is True
            assert moderator_perms["can_export_data"] is True
            assert moderator_perms["can_edit_project"] is False
            assert moderator_perms["can_delete_project"] is False
            assert moderator_perms["can_manage_users"] is False
            
            user_perms = ProjectPermission.get_default_permissions_for_role(ProjectRole.USER)
            assert user_perms["can_view_project"] is True
            assert user_perms["can_create_comments"] is True
            assert user_perms["can_upload_datasets"] is True
            assert user_perms["can_edit_project"] is False
            assert user_perms["can_moderate_comments"] is False
            assert user_perms["can_export_data"] is False
        
        def test_permission_application():
            # Test d'application des permissions par d√©faut
            permission = ProjectPermission(
                user_id=1,
                project_id=1,
                role=ProjectRole.MODERATOR
            )
            
            permission.apply_role_permissions()
            
            assert permission.can_view_project is True
            assert permission.can_moderate_comments is True
            assert permission.can_edit_project is False
        
        self.run_test("Permissions par d√©faut des r√¥les", test_permission_defaults)
        self.run_test("Application des permissions", test_permission_application)
    
    def test_security_logging(self):
        """Tests du syst√®me de journalisation de s√©curit√©"""
        print("üìã Tests de journalisation de s√©curit√©")
        
        def test_log_creation():
            logger = SecurityLogger(self.db)
            
            log_entry = logger.log_event(
                event_type=SecurityEventType.LOGIN_SUCCESS,
                user_email="test@example.com",
                ip_address="192.168.1.1",
                action="test_login",
                success=True,
                additional_data={"test": True}
            )
            
            assert log_entry.id is not None
            assert log_entry.event_type == SecurityEventType.LOGIN_SUCCESS
            assert log_entry.user_email == "test@example.com"
            assert log_entry.ip_address == "192.168.1.1"
            assert log_entry.success is True
            assert '"test": true' in log_entry.additional_data
        
        def test_different_event_types():
            logger = SecurityLogger(self.db)
            
            # Test diff√©rents types d'√©v√©nements
            events_to_test = [
                SecurityEventType.LOGIN_FAILED,
                SecurityEventType.ADMIN_ACCESS,
                SecurityEventType.SUSPICIOUS_ACTIVITY,
                SecurityEventType.DATA_EXPORTED,
                SecurityEventType.PERMISSION_GRANTED
            ]
            
            for event_type in events_to_test:
                log_entry = logger.log_event(
                    event_type=event_type,
                    ip_address="127.0.0.1",
                    action="test",
                    success=True
                )
                assert log_entry.event_type == event_type
        
        self.run_test("Cr√©ation d'√©v√©nements de s√©curit√©", test_log_creation)
        self.run_test("Diff√©rents types d'√©v√©nements", test_different_event_types)
    
    def run_all_tests(self):
        """Ex√©cute tous les tests de s√©curit√©"""
        print("üõ°Ô∏è  SUITE DE TESTS DE S√âCURIT√â AGORAFLUX")
        print("=" * 60)
        print(f"D√©but des tests : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        
        try:
            self.test_password_security()
            print()
            
            self.test_jwt_security()
            print()
            
            self.test_role_permissions()
            print()
            
            self.test_project_permissions()
            print()
            
            self.test_security_logging()
            print()
            
        except Exception as e:
            print(f"‚ùå Erreur fatale : {e}")
            if "--verbose" in sys.argv:
                traceback.print_exc()
        
        finally:
            self.db.close()
        
        # R√©sultats finaux
        total_tests = self.tests_passed + self.tests_failed
        success_rate = (self.tests_passed / total_tests * 100) if total_tests > 0 else 0
        
        print("=" * 60)
        print("üìä R√âSULTATS DES TESTS")
        print(f"   ‚úÖ Tests r√©ussis : {self.tests_passed}")
        print(f"   ‚ùå Tests √©chou√©s : {self.tests_failed}")
        print(f"   üìà Taux de r√©ussite : {success_rate:.1f}%")
        
        if self.tests_failed == 0:
            print("\nüéâ TOUS LES TESTS DE S√âCURIT√â PASSENT !")
            print("   ‚Ä¢ Syst√®me d'authentification s√©curis√©")
            print("   ‚Ä¢ Gestion robuste des permissions")
            print("   ‚Ä¢ Journalisation de s√©curit√© active")
            print("   ‚Ä¢ Protection contre les attaques")
            return True
        else:
            print(f"\n‚ö†Ô∏è  {self.tests_failed} TEST(S) √âCHOU√â(S)")
            print("   Veuillez corriger les probl√®mes avant la mise en production")
            return False


if __name__ == "__main__":
    # Cr√©er les tables si elles n'existent pas
    Base.metadata.create_all(bind=engine)
    
    # Ex√©cuter les tests
    test_suite = SecurityTestSuite()
    success = test_suite.run_all_tests()
    
    sys.exit(0 if success else 1) 